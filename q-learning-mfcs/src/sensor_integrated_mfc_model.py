"""
Sensor-Integrated MFC Model with EIS/QCM Feedback Loops

This module extends the integrated MFC model to include:
1. Real-time EIS and QCM sensor feedback
2. Sensor-guided biofilm and metabolic model validation
3. Adaptive parameter tuning based on sensor data
4. Enhanced Q-learning control with sensor state variables
5. Fault-tolerant operation with sensor degradation handling

The sensor integration provides closed-loop control and improved
accuracy through continuous validation of model predictions.
"""

import numpy as np
import pandas as pd
from typing import Dict, Tuple, List, Optional, Any
from dataclasses import dataclass
import time
import pickle
import os
import sys

# Import base integrated model
sys.path.append(os.path.dirname(__file__))
from integrated_mfc_model import IntegratedMFCModel, IntegratedMFCState

# Import enhanced components
from biofilm_kinetics.enhanced_biofilm_model import EnhancedBiofilmModel
from sensing_enhanced_q_controller import SensingEnhancedQLearningController

# Import sensing models
try:
    from sensing_models.eis_model import EISModel, BacterialSpecies
    from sensing_models.qcm_model import QCMModel
    from sensing_models.sensor_fusion import SensorFusion, FusionMethod
    SENSING_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Sensing models not available: {e}")
    SENSING_AVAILABLE = False

from mfc_recirculation_control import (
    AnolytereservoirSystem, 
    SubstrateConcentrationController,
    MFCCellWithMonitoring
)
from gpu_acceleration import get_gpu_accelerator
from path_config import get_model_path, get_simulation_data_path, get_figure_path


@dataclass
class SensorIntegratedMFCState(IntegratedMFCState):
    """Extended MFC state with sensor measurements."""
    
    # Sensor measurements (per cell)
    eis_thickness: List[float]
    eis_conductivity: List[float]
    eis_measurement_quality: List[float]
    
    qcm_mass_per_area: List[float]
    qcm_frequency_shift: List[float]
    qcm_dissipation: List[float]
    
    # Sensor fusion results (per cell)
    fused_thickness: List[float]
    fused_biomass: List[float]
    sensor_agreement: List[float]
    fusion_confidence: List[float]
    
    # Sensor status
    eis_sensor_status: List[str]
    qcm_sensor_status: List[str]
    sensor_fault_flags: List[bool]
    
    # Model validation metrics
    thickness_prediction_error: List[float]
    biomass_prediction_error: List[float]
    model_sensor_agreement: float
    adaptive_calibration_active: bool


class SensorIntegratedMFCModel(IntegratedMFCModel):
    """
    Complete MFC model with integrated sensor feedback loops.
    
    Features:
    - Real-time EIS and QCM sensor integration
    - Sensor-guided model validation and calibration
    - Enhanced Q-learning with sensor state variables
    - Fault-tolerant operation with sensor degradation
    - Multi-scale temporal dynamics with sensor feedback
    """
    
    def __init__(self, n_cells: int = 5, species: str = "mixed", 
                 substrate: str = "lactate", membrane_type: str = "Nafion-117",
                 use_gpu: bool = True, simulation_hours: int = 100,
                 enable_eis: bool = True, enable_qcm: bool = True,
                 sensor_fusion_method: str = 'kalman_filter',
                 sensor_feedback_weight: float = 0.3):
        """
        Initialize sensor-integrated MFC model.
        
        Args:
            n_cells: Number of cells in stack
            species: Bacterial species
            substrate: Substrate type
            membrane_type: Nafion membrane grade
            use_gpu: Enable GPU acceleration
            simulation_hours: Total simulation duration
            enable_eis: Enable EIS sensor integration
            enable_qcm: Enable QCM sensor integration
            sensor_fusion_method: Sensor fusion algorithm
            sensor_feedback_weight: Weight of sensor feedback in control
        """
        # Initialize base model (but don't call super().__init__ to avoid duplicate initialization)
        self.n_cells = n_cells
        self.species = species
        self.substrate = substrate
        self.membrane_type = membrane_type
        self.use_gpu = use_gpu
        self.simulation_hours = simulation_hours
        
        # Sensor configuration
        self.enable_eis = enable_eis and SENSING_AVAILABLE
        self.enable_qcm = enable_qcm and SENSING_AVAILABLE
        self.sensor_fusion_method = sensor_fusion_method
        self.sensor_feedback_weight = sensor_feedback_weight
        
        # GPU acceleration
        self.gpu_acc = get_gpu_accelerator() if use_gpu else None
        self.gpu_available = self.gpu_acc.is_gpu_available() if self.gpu_acc else False
        
        print(f"Initializing Sensor-Integrated MFC Model")
        print(f"Configuration: {n_cells} cells, {species} bacteria, {substrate} substrate")
        print(f"Sensors: EIS={self.enable_eis}, QCM={self.enable_qcm}")
        print(f"GPU Acceleration: {'Enabled' if self.gpu_available else 'Disabled'}\")\n        \n        # Initialize enhanced components\n        self._initialize_enhanced_models()\n        self._initialize_sensors()\n        self._initialize_recirculation()\n        self._initialize_tracking()\n    \n    def _initialize_enhanced_models(self):\n        \"\"\"Initialize enhanced biofilm and metabolic models.\"\"\"\n        # Create enhanced biofilm models for each cell\n        self.biofilm_models = []\n        self.metabolic_models = []\n        \n        for i in range(self.n_cells):\n            # Enhanced biofilm model with sensor integration\n            biofilm_model = EnhancedBiofilmModel(\n                species=self.species,\n                substrate=self.substrate,\n                use_gpu=self.use_gpu,\n                temperature=303.0,  # 30°C\n                ph=7.0,\n                enable_eis=self.enable_eis,\n                enable_qcm=self.enable_qcm,\n                sensor_fusion_method=self.sensor_fusion_method\n            )\n            self.biofilm_models.append(biofilm_model)\n            \n            # Standard metabolic model (will be enhanced in future)\n            from metabolic_model import MetabolicModel\n            metabolic_model = MetabolicModel(\n                species=self.species,\n                substrate=self.substrate,\n                membrane_type=self.membrane_type,\n                use_gpu=self.use_gpu\n            )\n            self.metabolic_models.append(metabolic_model)\n    \n    def _initialize_sensors(self):\n        \"\"\"Initialize sensor models for each cell.\"\"\"\n        self.eis_models = []\n        self.qcm_models = []\n        self.sensor_fusion_models = []\n        \n        if not SENSING_AVAILABLE:\n            print(\"Warning: Sensing models not available - running without sensors\")\n            return\n        \n        # Map species names\n        species_map = {\n            'geobacter': BacterialSpecies.GEOBACTER,\n            'shewanella': BacterialSpecies.SHEWANELLA,\n            'mixed': BacterialSpecies.MIXED\n        }\n        \n        for i in range(self.n_cells):\n            # EIS sensor for each cell\n            if self.enable_eis:\n                eis_model = EISModel(\n                    species=species_map.get(self.species, BacterialSpecies.MIXED),\n                    electrode_area=1e-4,  # 1 cm² per cell\n                    use_gpu=self.use_gpu\n                )\n                self.eis_models.append(eis_model)\n            \n            # QCM sensor for each cell\n            if self.enable_qcm:\n                qcm_model = QCMModel(\n                    electrode_area=0.196,  # 5mm diameter\n                    use_gpu=self.use_gpu\n                )\n                qcm_model.set_biofilm_species(self.species)\n                self.qcm_models.append(qcm_model)\n            \n            # Sensor fusion for each cell\n            if self.enable_eis and self.enable_qcm:\n                fusion_method_map = {\n                    'kalman_filter': FusionMethod.KALMAN_FILTER,\n                    'weighted_average': FusionMethod.WEIGHTED_AVERAGE,\n                    'maximum_likelihood': FusionMethod.MAXIMUM_LIKELIHOOD,\n                    'bayesian': FusionMethod.BAYESIAN_INFERENCE\n                }\n                \n                fusion_model = SensorFusion(\n                    method=fusion_method_map.get(self.sensor_fusion_method, FusionMethod.KALMAN_FILTER),\n                    species=species_map.get(self.species, BacterialSpecies.MIXED),\n                    use_gpu=self.use_gpu\n                )\n                self.sensor_fusion_models.append(fusion_model)\n    \n    def _initialize_recirculation(self):\n        \"\"\"Initialize recirculation and enhanced control systems.\"\"\"\n        # Initialize reservoir\n        self.reservoir = AnolytereservoirSystem(\n            initial_substrate_conc=20.0,  # mmol/L\n            volume_liters=1.0\n        )\n        \n        # Initialize MFC cells\n        self.mfc_cells = [\n            MFCCellWithMonitoring(i+1, initial_biofilm=1.0) \n            for i in range(self.n_cells)\n        ]\n        \n        # Enhanced Q-learning flow controller with sensor integration\n        self.flow_controller = SensingEnhancedQLearningController(\n            enable_sensor_state=self.enable_eis or self.enable_qcm,\n            sensor_weight=self.sensor_feedback_weight,\n            fault_tolerance=True\n        )\n        \n        # Substrate controller\n        self.substrate_controller = SubstrateConcentrationController(\n            target_outlet_conc=12.0,\n            target_reservoir_conc=20.0\n        )\n        \n        # Simulation state\n        self.flow_rate_ml_h = 10.0\n        self.total_energy_generated = 0.0\n        self.pump_power_consumed = 0.0\n        \n        # Sensor feedback state\n        self.sensor_data_history = []\n        self.sensor_fault_history = []\n        self.adaptive_calibration_events = []\n    \n    def _initialize_tracking(self):\n        \"\"\"Initialize enhanced tracking variables.\"\"\"\n        self.time = 0.0\n        self.history = []\n        self.biofilm_history = []\n        self.metabolic_history = []\n        self.sensor_history = []\n        \n        self.performance_metrics = {\n            'total_energy': 0.0,\n            'average_power': 0.0,\n            'max_power': 0.0,\n            'coulombic_efficiency': 0.0,\n            'substrate_utilization': 0.0,\n            'sensor_accuracy': 0.0,\n            'model_validation_score': 0.0\n        }\n    \n    def step_sensor_integrated_dynamics(self, dt: float = 1.0) -> SensorIntegratedMFCState:\n        \"\"\"\n        Step the sensor-integrated model forward by dt hours.\n        \n        Args:\n            dt: Time step (hours)\n            \n        Returns:\n            SensorIntegratedMFCState with sensor measurements\n        \"\"\"\n        # 1. Get inlet concentration from reservoir\n        inlet_conc = self.reservoir.get_inlet_concentration()\n        \n        # 2. Update enhanced biofilm dynamics with sensor feedback\n        biofilm_states = []\n        sensor_measurements = []\n        \n        for i in range(self.n_cells):\n            # Get cell-specific conditions\n            cell = self.mfc_cells[i]\n            anode_potential = -0.3 + getattr(cell, 'anode_overpotential', 0.1)\n            \n            # Step enhanced biofilm model with sensors\n            if hasattr(self.biofilm_models[i], 'step_biofilm_dynamics_with_sensors'):\n                biofilm_state = self.biofilm_models[i].step_biofilm_dynamics_with_sensors(\n                    dt=dt,\n                    anode_potential=anode_potential,\n                    substrate_supply=inlet_conc / 10.0,\n                    time_hours=self.time\n                )\n            else:\n                # Fallback to standard biofilm model\n                biofilm_state = self.biofilm_models[i].step_biofilm_dynamics(\n                    dt=dt,\n                    anode_potential=anode_potential,\n                    substrate_supply=inlet_conc / 10.0\n                )\n                \n                # Add empty sensor data\n                biofilm_state.update({\n                    'sensor_validated_thickness': biofilm_state['biofilm_thickness'],\n                    'sensor_validated_biomass': biofilm_state['biomass_density'],\n                    'sensor_confidence': 0.0,\n                    'fusion_confidence': 0.0,\n                    'sensor_status': 'unavailable'\n                })\n            \n            biofilm_states.append(biofilm_state)\n            \n            # Collect sensor measurements if available\n            if SENSING_AVAILABLE and (self.enable_eis or self.enable_qcm):\n                cell_sensor_data = self._collect_cell_sensor_data(\n                    i, biofilm_state, self.time\n                )\n                sensor_measurements.append(cell_sensor_data)\n            else:\n                sensor_measurements.append({})\n        \n        # 3. Update metabolic dynamics\n        metabolic_states = []\n        for i in range(self.n_cells):\n            # Use sensor-validated biofilm parameters if available\n            biomass = biofilm_states[i].get('sensor_validated_biomass', \n                                           biofilm_states[i]['biomass_density'])\n            growth_rate = biofilm_states[i]['growth_rate']\n            \n            # Step metabolic model\n            metabolic_state = self.metabolic_models[i].step_metabolism(\n                dt=dt,\n                biomass=biomass,\n                growth_rate=growth_rate,\n                anode_potential=anode_potential,\n                substrate_supply=inlet_conc / 20.0,\n                cathode_o2_conc=0.25,  # mol/m³\n                membrane_area=0.01,    # m²\n                volume=0.1,           # L per cell\n                electrode_area=0.01   # m²  \n            )\n            metabolic_states.append(metabolic_state)\n        \n        # 4. Enhanced Q-learning control with sensor data\n        current_concentrations = [cell.substrate_concentration for cell in self.mfc_cells]\n        outlet_conc = current_concentrations[-1] if current_concentrations else inlet_conc\n        \n        # Prepare base state for Q-learning\n        avg_biofilm = np.mean([bs['biofilm_thickness'] for bs in biofilm_states])\n        biofilm_deviation = abs(avg_biofilm - 30.0)  # 30 μm target\n        substrate_utilization = ((inlet_conc - outlet_conc) / \n                               inlet_conc * 100 if inlet_conc > 0 else 0)\n        \n        base_state = self.flow_controller.discretize_enhanced_state(\n            sum([0.35 * bs['biofilm_thickness'] * bs['biomass_density'] * 0.002 \n                for bs in biofilm_states]),  # Total power estimate\n            biofilm_deviation,\n            substrate_utilization,\n            self.reservoir.substrate_concentration,\n            min(current_concentrations) if current_concentrations else 0,\n            abs(outlet_conc - 12.0),  # Target outlet concentration\n            self.time\n        )\n        \n        # Prepare sensor data for Q-learning\n        aggregated_sensor_data = self._aggregate_sensor_data(sensor_measurements)\n        \n        # Choose action with sensor enhancement\n        if hasattr(self.flow_controller, 'choose_action_with_sensors'):\n            action = self.flow_controller.choose_action_with_sensors(\n                base_state, aggregated_sensor_data\n            )\n        else:\n            # Fallback to standard action selection\n            action = np.random.choice(len(self.flow_controller.actions))\n        \n        # Update flow rate\n        flow_adjustment = self.flow_controller.actions[action]\n        self.flow_rate_ml_h = max(5.0, min(50.0, self.flow_rate_ml_h + flow_adjustment))\n        \n        # 5. Update MFC cells with enhanced current calculations\n        enhanced_currents = []\n        cell_voltages = []\n        \n        for i in range(self.n_cells):\n            cell = self.mfc_cells[i]\n            \n            # Process cell with monitoring\n            if hasattr(cell, 'update_concentrations'):\n                cell.update_concentrations(inlet_conc, self.flow_rate_ml_h, dt)\n            \n            # Calculate enhanced current with sensor validation\n            base_current = getattr(cell, 'current', 0.1)  # Default current\n            \n            # Apply biofilm enhancement\n            biofilm_current = self._calculate_biofilm_current_enhancement(\n                biofilm_states[i], sensor_measurements[i]\n            )\n            \n            # Apply metabolic enhancement\n            metabolic_current = metabolic_states[i].fluxes.get('GSU_R004', 0.0) * 0.001\n            \n            # Total enhanced current\n            total_current = base_current + biofilm_current + metabolic_current\n            enhanced_currents.append(total_current)\n            \n            # Cell voltage (simplified)\n            cell_voltage = 0.35  # Acetate-specific potential\n            cell_voltages.append(cell_voltage)\n        \n        # 6. Update reservoir with recirculation\n        self.reservoir.circulate_anolyte(\n            flow_rate_ml_h=self.flow_rate_ml_h,\n            stack_outlet_conc=outlet_conc,\n            dt_hours=dt\n        )\n        \n        # 7. Substrate addition control\n        cell_concentrations = [cell.substrate_concentration for cell in self.mfc_cells]\n        substrate_addition, halt_flag = self.substrate_controller.calculate_substrate_addition(\n            outlet_conc=outlet_conc,\n            reservoir_conc=self.reservoir.substrate_concentration,\n            cell_concentrations=cell_concentrations,\n            reservoir_sensors=self.reservoir.get_sensor_readings(),\n            dt_hours=dt\n        )\n        \n        self.reservoir.add_substrate(substrate_addition, dt)\n        \n        # 8. Update energy and power tracking\n        total_power = sum(v * i for v, i in zip(cell_voltages, enhanced_currents))\n        self.total_energy_generated += total_power * dt\n        self.pump_power_consumed += 0.001 * self.flow_rate_ml_h * dt\n        \n        # 9. Calculate model validation metrics\n        model_validation_score = self._calculate_model_validation_score(\n            biofilm_states, sensor_measurements\n        )\n        \n        # 10. Handle sensor faults if detected\n        self._handle_sensor_faults(sensor_measurements)\n        \n        # 11. Update time and tracking\n        self.time += dt\n        \n        # 12. Create sensor-integrated state\n        integrated_state = self._create_sensor_integrated_state(\n            biofilm_states, metabolic_states, sensor_measurements,\n            enhanced_currents, cell_voltages, total_power, model_validation_score\n        )\n        \n        # Store history\n        self.history.append(integrated_state)\n        self.sensor_history.append(sensor_measurements)\n        \n        return integrated_state\n    \n    def _collect_cell_sensor_data(self, cell_index: int, biofilm_state: Dict, \n                                 time_hours: float) -> Dict:\n        \"\"\"Collect sensor data for a specific cell.\"\"\"\n        sensor_data = {\n            'eis': {},\n            'qcm': {},\n            'fusion': {}\n        }\n        \n        # Collect EIS data\n        if self.enable_eis and cell_index < len(self.eis_models):\n            try:\n                thickness = biofilm_state.get('sensor_validated_thickness', \n                                             biofilm_state['biofilm_thickness'])\n                biomass = biofilm_state.get('sensor_validated_biomass',\n                                          biofilm_state['biomass_density'])\n                \n                eis_measurements = self.eis_models[cell_index].simulate_measurement(\n                    biofilm_thickness=thickness,\n                    biomass_density=biomass,\n                    time_hours=time_hours\n                )\n                \n                eis_properties = self.eis_models[cell_index].get_biofilm_properties(eis_measurements)\n                \n                sensor_data['eis'] = {\n                    'measurements': eis_measurements,\n                    'properties': eis_properties,\n                    'status': 'good' if eis_properties.get('measurement_quality', 0) > 0.7 else 'degraded'\n                }\n                \n            except Exception as e:\n                print(f\"Warning: EIS measurement failed for cell {cell_index}: {e}\")\n                sensor_data['eis']['status'] = 'failed'\n        \n        # Collect QCM data\n        if self.enable_qcm and cell_index < len(self.qcm_models):\n            try:\n                thickness = biofilm_state.get('sensor_validated_thickness',\n                                             biofilm_state['biofilm_thickness'])\n                biomass = biofilm_state.get('sensor_validated_biomass',\n                                          biofilm_state['biomass_density'])\n                \n                # Estimate mass from biomass and thickness\n                electrode_area = 0.196  # cm²\n                thickness_cm = thickness * 1e-4\n                volume_cm3 = electrode_area * thickness_cm\n                mass_ug = biomass * volume_cm3 * 1e3  # g/L to μg\n                \n                qcm_measurement = self.qcm_models[cell_index].simulate_measurement(\n                    biofilm_mass=mass_ug,\n                    biofilm_thickness=thickness,\n                    time_hours=time_hours\n                )\n                \n                qcm_properties = self.qcm_models[cell_index].estimate_biofilm_properties(qcm_measurement)\n                \n                sensor_data['qcm'] = {\n                    'measurement': qcm_measurement,\n                    'properties': qcm_properties,\n                    'status': 'good' if qcm_properties.get('measurement_quality', 0) > 0.7 else 'degraded'\n                }\n                \n            except Exception as e:\n                print(f\"Warning: QCM measurement failed for cell {cell_index}: {e}\")\n                sensor_data['qcm']['status'] = 'failed'\n        \n        # Perform sensor fusion if both sensors available\n        if (sensor_data['eis'].get('measurements') and sensor_data['qcm'].get('measurement') and\n            cell_index < len(self.sensor_fusion_models)):\n            try:\n                fused_result = self.sensor_fusion_models[cell_index].fuse_measurements(\n                    eis_measurement=sensor_data['eis']['measurements'][0],\n                    qcm_measurement=sensor_data['qcm']['measurement'],\n                    eis_properties=sensor_data['eis']['properties'],\n                    qcm_properties=sensor_data['qcm']['properties'],\n                    time_hours=time_hours\n                )\n                \n                sensor_data['fusion'] = {\n                    'fused_result': fused_result,\n                    'thickness': fused_result.thickness_um,\n                    'biomass': fused_result.biomass_density_g_per_L,\n                    'sensor_agreement': fused_result.sensor_agreement,\n                    'fusion_confidence': fused_result.fusion_confidence,\n                    'status': 'good' if fused_result.fusion_confidence > 0.7 else 'degraded'\n                }\n                \n            except Exception as e:\n                print(f\"Warning: Sensor fusion failed for cell {cell_index}: {e}\")\n                sensor_data['fusion']['status'] = 'failed'\n        \n        return sensor_data\n    \n    def _aggregate_sensor_data(self, sensor_measurements: List[Dict]) -> Dict:\n        \"\"\"Aggregate sensor data from all cells for Q-learning.\"\"\"\n        if not sensor_measurements or not any(sensor_measurements):\n            return {}\n        \n        # Aggregate EIS data\n        eis_thicknesses = []\n        eis_conductivities = []\n        eis_qualities = []\n        \n        # Aggregate QCM data\n        qcm_masses = []\n        qcm_freq_shifts = []\n        qcm_dissipations = []\n        \n        # Aggregate fusion data\n        sensor_agreements = []\n        fusion_confidences = []\n        \n        for sensor_data in sensor_measurements:\n            # EIS data\n            if 'eis' in sensor_data and 'properties' in sensor_data['eis']:\n                eis_props = sensor_data['eis']['properties']\n                eis_thicknesses.append(eis_props.get('thickness_um', 0))\n                eis_conductivities.append(eis_props.get('conductivity_S_per_m', 0))\n                eis_qualities.append(eis_props.get('measurement_quality', 0))\n            \n            # QCM data\n            if 'qcm' in sensor_data and 'properties' in sensor_data['qcm']:\n                qcm_props = sensor_data['qcm']['properties']\n                qcm_masses.append(qcm_props.get('mass_per_area_ng_per_cm2', 0))\n                \n                if 'measurement' in sensor_data['qcm']:\n                    qcm_meas = sensor_data['qcm']['measurement']\n                    qcm_freq_shifts.append(abs(qcm_meas.frequency_shift))\n                    qcm_dissipations.append(qcm_meas.dissipation)\n            \n            # Fusion data\n            if 'fusion' in sensor_data and 'sensor_agreement' in sensor_data['fusion']:\n                sensor_agreements.append(sensor_data['fusion']['sensor_agreement'])\n                fusion_confidences.append(sensor_data['fusion']['fusion_confidence'])\n        \n        # Calculate aggregated metrics\n        aggregated = {}\n        \n        if eis_thicknesses:\n            aggregated['eis'] = {\n                'thickness_um': np.mean(eis_thicknesses),\n                'conductivity_S_per_m': np.mean(eis_conductivities),\n                'measurement_quality': np.mean(eis_qualities),\n                'status': 'good' if np.mean(eis_qualities) > 0.7 else 'degraded'\n            }\n        \n        if qcm_masses:\n            aggregated['qcm'] = {\n                'mass_per_area_ng_per_cm2': np.mean(qcm_masses),\n                'frequency_shift_Hz': np.mean(qcm_freq_shifts) if qcm_freq_shifts else 0,\n                'dissipation': np.mean(qcm_dissipations) if qcm_dissipations else 0,\n                'measurement_quality': 0.8,  # Simplified\n                'status': 'good'\n            }\n        \n        if sensor_agreements:\n            aggregated['fusion'] = {\n                'sensor_agreement': np.mean(sensor_agreements),\n                'fusion_confidence': np.mean(fusion_confidences),\n                'status': 'good' if np.mean(fusion_confidences) > 0.7 else 'degraded'\n            }\n        \n        return aggregated\n    \n    def _calculate_biofilm_current_enhancement(self, biofilm_state: Dict, \n                                             sensor_data: Dict) -> float:\n        \"\"\"Calculate biofilm current enhancement based on sensor data.\"\"\"\n        # Use sensor-validated thickness if available\n        if 'fusion' in sensor_data and 'thickness' in sensor_data['fusion']:\n            thickness = sensor_data['fusion']['thickness']\n            confidence = sensor_data['fusion'].get('fusion_confidence', 0.5)\n        elif 'eis' in sensor_data and 'properties' in sensor_data['eis']:\n            thickness = sensor_data['eis']['properties'].get('thickness_um', 0)\n            confidence = sensor_data['eis']['properties'].get('measurement_quality', 0.5)\n        else:\n            thickness = biofilm_state['biofilm_thickness']\n            confidence = 0.5\n        \n        # Calculate current density based on validated thickness\n        base_current_density = 0.0001  # A/cm²\n        thickness_factor = min(thickness / 30.0, 2.0)  # Normalize to 30 μm optimal\n        confidence_factor = 0.5 + 0.5 * confidence  # Scale by sensor confidence\n        \n        enhanced_current = base_current_density * thickness_factor * confidence_factor\n        \n        return enhanced_current\n    \n    def _calculate_model_validation_score(self, biofilm_states: List[Dict],\n                                        sensor_measurements: List[Dict]) -> float:\n        \"\"\"Calculate model validation score based on sensor agreement.\"\"\"\n        if not sensor_measurements or not any(sensor_measurements):\n            return 0.5  # Neutral score without sensors\n        \n        validation_scores = []\n        \n        for i, (biofilm_state, sensor_data) in enumerate(zip(biofilm_states, sensor_measurements)):\n            model_thickness = biofilm_state['biofilm_thickness']\n            model_biomass = biofilm_state['biomass_density']\n            \n            # Compare with sensor measurements\n            if 'fusion' in sensor_data and 'thickness' in sensor_data['fusion']:\n                sensor_thickness = sensor_data['fusion']['thickness']\n                sensor_biomass = sensor_data['fusion']['biomass']\n                \n                # Calculate relative errors\n                thickness_error = abs(model_thickness - sensor_thickness) / max(sensor_thickness, 1.0)\n                biomass_error = abs(model_biomass - sensor_biomass) / max(sensor_biomass, 1.0)\n                \n                # Convert to validation score (lower error = higher score)\n                thickness_score = max(0, 1.0 - thickness_error)\n                biomass_score = max(0, 1.0 - biomass_error)\n                \n                cell_score = (thickness_score + biomass_score) / 2\n                validation_scores.append(cell_score)\n        \n        return np.mean(validation_scores) if validation_scores else 0.5\n    \n    def _handle_sensor_faults(self, sensor_measurements: List[Dict]):\n        \"\"\"Handle detected sensor faults.\"\"\"\n        for i, sensor_data in enumerate(sensor_measurements):\n            # Check EIS faults\n            if 'eis' in sensor_data and sensor_data['eis'].get('status') == 'failed':\n                if hasattr(self.flow_controller, 'handle_sensor_fault'):\n                    self.flow_controller.handle_sensor_fault('failed', 'eis')\n                self.sensor_fault_history.append({\n                    'time': self.time,\n                    'cell': i,\n                    'sensor': 'eis',\n                    'fault_type': 'failed'\n                })\n            \n            # Check QCM faults\n            if 'qcm' in sensor_data and sensor_data['qcm'].get('status') == 'failed':\n                if hasattr(self.flow_controller, 'handle_sensor_fault'):\n                    self.flow_controller.handle_sensor_fault('failed', 'qcm')\n                self.sensor_fault_history.append({\n                    'time': self.time,\n                    'cell': i,\n                    'sensor': 'qcm',\n                    'fault_type': 'failed'\n                })\n    \n    def _create_sensor_integrated_state(self, biofilm_states: List[Dict],\n                                      metabolic_states: List, sensor_measurements: List[Dict],\n                                      enhanced_currents: List[float], cell_voltages: List[float],\n                                      total_power: float, model_validation_score: float) -> SensorIntegratedMFCState:\n        \"\"\"Create comprehensive sensor-integrated state.\"\"\"\n        # Extract sensor data\n        eis_thickness = []\n        eis_conductivity = []\n        eis_quality = []\n        eis_status = []\n        \n        qcm_mass = []\n        qcm_freq_shift = []\n        qcm_dissipation = []\n        qcm_status = []\n        \n        fused_thickness = []\n        fused_biomass = []\n        sensor_agreement = []\n        fusion_confidence = []\n        sensor_faults = []\n        \n        thickness_errors = []\n        biomass_errors = []\n        \n        for i, (biofilm_state, sensor_data) in enumerate(zip(biofilm_states, sensor_measurements)):\n            # EIS data\n            if 'eis' in sensor_data and 'properties' in sensor_data['eis']:\n                eis_props = sensor_data['eis']['properties']\n                eis_thickness.append(eis_props.get('thickness_um', 0))\n                eis_conductivity.append(eis_props.get('conductivity_S_per_m', 0))\n                eis_quality.append(eis_props.get('measurement_quality', 0))\n                eis_status.append(sensor_data['eis'].get('status', 'unavailable'))\n            else:\n                eis_thickness.append(0)\n                eis_conductivity.append(0)\n                eis_quality.append(0)\n                eis_status.append('unavailable')\n            \n            # QCM data\n            if 'qcm' in sensor_data and 'measurement' in sensor_data['qcm']:\n                qcm_meas = sensor_data['qcm']['measurement']\n                qcm_props = sensor_data['qcm']['properties']\n                qcm_mass.append(qcm_props.get('mass_per_area_ng_per_cm2', 0))\n                qcm_freq_shift.append(qcm_meas.frequency_shift)\n                qcm_dissipation.append(qcm_meas.dissipation)\n                qcm_status.append(sensor_data['qcm'].get('status', 'unavailable'))\n            else:\n                qcm_mass.append(0)\n                qcm_freq_shift.append(0)\n                qcm_dissipation.append(0)\n                qcm_status.append('unavailable')\n            \n            # Fusion data\n            if 'fusion' in sensor_data and 'thickness' in sensor_data['fusion']:\n                fused_thickness.append(sensor_data['fusion']['thickness'])\n                fused_biomass.append(sensor_data['fusion']['biomass'])\n                sensor_agreement.append(sensor_data['fusion']['sensor_agreement'])\n                fusion_confidence.append(sensor_data['fusion']['fusion_confidence'])\n            else:\n                fused_thickness.append(biofilm_state['biofilm_thickness'])\n                fused_biomass.append(biofilm_state['biomass_density'])\n                sensor_agreement.append(0.5)\n                fusion_confidence.append(0.0)\n            \n            # Prediction errors\n            model_thickness = biofilm_state['biofilm_thickness']\n            model_biomass = biofilm_state['biomass_density']\n            sensor_thickness = fused_thickness[-1]\n            sensor_biomass = fused_biomass[-1]\n            \n            thickness_errors.append(abs(model_thickness - sensor_thickness))\n            biomass_errors.append(abs(model_biomass - sensor_biomass))\n            \n            # Sensor faults\n            has_fault = (eis_status[-1] == 'failed' or qcm_status[-1] == 'failed')\n            sensor_faults.append(has_fault)\n        \n        # Create state\n        return SensorIntegratedMFCState(\n            # Base state\n            time=self.time,\n            total_energy=self.total_energy_generated,\n            average_power=self.total_energy_generated / (self.time + 1e-6),\n            coulombic_efficiency=np.mean([ms.coulombic_efficiency for ms in metabolic_states]),\n            biofilm_thickness=[bs['biofilm_thickness'] for bs in biofilm_states],\n            biomass_density=[bs['biomass_density'] for bs in biofilm_states],\n            attachment_fraction=[0.5] * self.n_cells,  # Simplified\n            substrate_concentration=[ms.metabolites[self.substrate] for ms in metabolic_states],\n            nadh_ratio=[ms.metabolites['nadh']/(ms.metabolites['nadh']+ms.metabolites['nad_plus']) \n                       for ms in metabolic_states],\n            atp_level=[ms.metabolites['atp'] for ms in metabolic_states],\n            electron_flux=[ms.electron_production for ms in metabolic_states],\n            cell_voltages=cell_voltages,\n            current_densities=[c/0.01 for c in enhanced_currents],\n            anode_potentials=[-0.3] * self.n_cells,\n            reservoir_concentration=self.reservoir.substrate_concentration,\n            flow_rate=self.flow_rate_ml_h,\n            pump_power=self.pump_power_consumed,\n            epsilon=self.flow_controller.epsilon,\n            q_table_size=len(self.flow_controller.q_table),\n            learning_progress=1.0 - self.flow_controller.epsilon/0.3,\n            \n            # Sensor measurements\n            eis_thickness=eis_thickness,\n            eis_conductivity=eis_conductivity,\n            eis_measurement_quality=eis_quality,\n            qcm_mass_per_area=qcm_mass,\n            qcm_frequency_shift=qcm_freq_shift,\n            qcm_dissipation=qcm_dissipation,\n            \n            # Sensor fusion results\n            fused_thickness=fused_thickness,\n            fused_biomass=fused_biomass,\n            sensor_agreement=sensor_agreement,\n            fusion_confidence=fusion_confidence,\n            \n            # Sensor status\n            eis_sensor_status=eis_status,\n            qcm_sensor_status=qcm_status,\n            sensor_fault_flags=sensor_faults,\n            \n            # Model validation\n            thickness_prediction_error=thickness_errors,\n            biomass_prediction_error=biomass_errors,\n            model_sensor_agreement=np.mean(sensor_agreement),\n            adaptive_calibration_active=len(self.adaptive_calibration_events) > 0\n        )\n    \n    def run_sensor_integrated_simulation(self, dt: float = 1.0, \n                                       save_interval: int = 10) -> Dict[str, Any]:\n        \"\"\"\n        Run complete sensor-integrated simulation.\n        \n        Args:\n            dt: Time step (hours)\n            save_interval: Save results every N hours\n            \n        Returns:\n            Dictionary with enhanced simulation results\n        \"\"\"\n        print(f\"\\nStarting Sensor-Integrated MFC Simulation\")\n        print(f\"Duration: {self.simulation_hours} hours\")\n        print(f\"Time step: {dt} hours\")\n        print(f\"Sensors: EIS={self.enable_eis}, QCM={self.enable_qcm}\")\n        \n        start_time = time.time()\n        \n        # Main simulation loop\n        for hour in range(int(self.simulation_hours / dt)):\n            # Step sensor-integrated dynamics\n            state = self.step_sensor_integrated_dynamics(dt)\n            \n            # Progress update\n            if hour % 10 == 0:\n                sensor_info = f\"Sensor Agreement={state.model_sensor_agreement:.2%}\" if SENSING_AVAILABLE else \"No Sensors\"\n                print(f\"Hour {self.time:.1f}: Power={state.average_power:.3f}W, \"\n                      f\"CE={state.coulombic_efficiency:.2%}, \"\n                      f\"Biofilm={np.mean(state.biofilm_thickness):.1f}μm, \"\n                      f\"{sensor_info}\")\n            \n            # Save checkpoint\n            if hour % save_interval == 0 and hour > 0:\n                self._save_sensor_checkpoint(hour)\n        \n        # Final statistics\n        computation_time = time.time() - start_time\n        \n        results = self._compile_sensor_results()\n        results['computation_time'] = computation_time\n        \n        print(f\"\\nSensor-Integrated Simulation Complete!\")\n        print(f\"Total Energy: {results['total_energy']:.2f} Wh\")\n        print(f\"Average Power: {results['average_power']:.3f} W\")\n        print(f\"Model Validation Score: {results.get('average_model_validation', 0):.2%}\")\n        if SENSING_AVAILABLE:\n            print(f\"Sensor Integration: {results.get('sensor_integration_score', 0):.2%}\")\n        print(f\"Computation Time: {computation_time:.1f} seconds\")\n        \n        return results\n    \n    def _save_sensor_checkpoint(self, hour: int):\n        \"\"\"Save sensor-enhanced checkpoint data.\"\"\"\n        checkpoint = {\n            'hour': hour,\n            'time': self.time,\n            'history': self.history[-100:],\n            'sensor_history': self.sensor_history[-100:],\n            'sensor_fault_history': self.sensor_fault_history,\n            'adaptive_calibration_events': self.adaptive_calibration_events,\n            'q_table': dict(self.flow_controller.q_table) if hasattr(self.flow_controller, 'q_table') else {},\n            'performance_metrics': self.performance_metrics\n        }\n        \n        filename = get_model_path(f'sensor_integrated_checkpoint_h{hour}.pkl')\n        with open(filename, 'wb') as f:\n            pickle.dump(checkpoint, f)\n    \n    def _compile_sensor_results(self) -> Dict[str, Any]:\n        \"\"\"Compile sensor-enhanced simulation results.\"\"\"\n        if not self.history:\n            return {}\n        \n        # Base results\n        results = super()._compile_results() if hasattr(super(), '_compile_results') else {}\n        \n        # Add sensor-specific results\n        if SENSING_AVAILABLE and self.history:\n            # Extract sensor data from history\n            sensor_agreements = [getattr(s, 'model_sensor_agreement', 0.5) for s in self.history]\n            fusion_confidences = [np.mean(getattr(s, 'fusion_confidence', [0.5])) for s in self.history]\n            thickness_errors = [np.mean(getattr(s, 'thickness_prediction_error', [0])) for s in self.history]\n            \n            results.update({\n                'sensor_integration_score': np.mean(sensor_agreements),\n                'average_fusion_confidence': np.mean(fusion_confidences),\n                'average_thickness_error': np.mean(thickness_errors),\n                'sensor_fault_count': len(self.sensor_fault_history),\n                'adaptive_calibration_events': len(self.adaptive_calibration_events),\n                'average_model_validation': np.mean(sensor_agreements)\n            })\n        \n        # Controller performance\n        if hasattr(self.flow_controller, 'get_controller_performance_summary'):\n            controller_performance = self.flow_controller.get_controller_performance_summary()\n            results['controller_performance'] = controller_performance\n        \n        return results\n    \n    def get_sensor_diagnostics(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive sensor diagnostics.\"\"\"\n        diagnostics = {\n            'sensor_availability': {\n                'sensing_models_available': SENSING_AVAILABLE,\n                'eis_enabled': self.enable_eis,\n                'qcm_enabled': self.enable_qcm,\n                'sensor_fusion_enabled': self.enable_eis and self.enable_qcm,\n                'n_eis_models': len(self.eis_models) if hasattr(self, 'eis_models') else 0,\n                'n_qcm_models': len(self.qcm_models) if hasattr(self, 'qcm_models') else 0,\n                'n_fusion_models': len(self.sensor_fusion_models) if hasattr(self, 'sensor_fusion_models') else 0\n            },\n            'sensor_performance': {\n                'total_measurements': len(self.sensor_history),\n                'fault_events': len(self.sensor_fault_history),\n                'calibration_events': len(self.adaptive_calibration_events)\n            }\n        }\n        \n        # Add individual sensor diagnostics\n        if hasattr(self, 'biofilm_models'):\n            for i, model in enumerate(self.biofilm_models):\n                if hasattr(model, 'get_sensor_diagnostics'):\n                    diagnostics[f'cell_{i}_biofilm_sensor_diagnostics'] = model.get_sensor_diagnostics()\n        \n        # Add controller diagnostics\n        if hasattr(self.flow_controller, 'get_controller_performance_summary'):\n            diagnostics['controller_diagnostics'] = self.flow_controller.get_controller_performance_summary()\n        \n        return diagnostics\n\n\ndef main():\n    \"\"\"Main function to run sensor-integrated simulation.\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(description='Sensor-Integrated MFC Model Simulation')\n    parser.add_argument('--cells', type=int, default=5, help='Number of cells')\n    parser.add_argument('--species', choices=['geobacter', 'shewanella', 'mixed'], \n                       default='mixed', help='Bacterial species')\n    parser.add_argument('--substrate', choices=['acetate', 'lactate'], \n                       default='lactate', help='Substrate type')\n    parser.add_argument('--hours', type=int, default=100, help='Simulation duration')\n    parser.add_argument('--gpu', action='store_true', help='Enable GPU acceleration')\n    parser.add_argument('--eis', action='store_true', default=True, help='Enable EIS sensors')\n    parser.add_argument('--qcm', action='store_true', default=True, help='Enable QCM sensors')\n    parser.add_argument('--fusion', choices=['kalman_filter', 'weighted_average', 'maximum_likelihood', 'bayesian'],\n                       default='kalman_filter', help='Sensor fusion method')\n    parser.add_argument('--plot', action='store_true', help='Generate plots')\n    \n    args = parser.parse_args()\n    \n    # Create and run model\n    model = SensorIntegratedMFCModel(\n        n_cells=args.cells,\n        species=args.species,\n        substrate=args.substrate,\n        use_gpu=args.gpu,\n        simulation_hours=args.hours,\n        enable_eis=args.eis,\n        enable_qcm=args.qcm,\n        sensor_fusion_method=args.fusion\n    )\n    \n    # Run simulation\n    results = model.run_sensor_integrated_simulation()\n    \n    # Save results\n    if hasattr(model, 'save_results'):\n        model.save_results(results, prefix=\"sensor_integrated\")\n    \n    # Generate plots\n    if args.plot and hasattr(model, 'plot_results'):\n        model.plot_results(results)\n    \n    # Print diagnostics\n    diagnostics = model.get_sensor_diagnostics()\n    print(\"\\n=== Sensor Diagnostics ===\")\n    for key, value in diagnostics.items():\n        if isinstance(value, dict):\n            print(f\"{key}:\")\n            for k, v in value.items():\n                print(f\"  {k}: {v}\")\n        else:\n            print(f\"{key}: {value}\")\n\n\nif __name__ == \"__main__\":\n    main()